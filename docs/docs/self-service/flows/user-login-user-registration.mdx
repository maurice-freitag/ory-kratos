---
id: user-login-user-registration
title: User Login And Registration
sidebar_label: Overview
---

import Mermaid from '@theme/Mermaid'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

// import InitBrowserFlow from '@theme/Code/Login/InitBrowserFlow'
import SelfServiceBrowserFlow from '@theme/SelfServiceBrowserFlow'
import SelfServiceAPIFlow from '@theme/SelfServiceAPIFlow'
import CodeFromRemote from '@theme/CodeFromRemote'

There are two login and registration flow types supported in ORY Kratos:

- Flows where the user sits in front of the Browser (e.g. website, single page
  app, ...)
- Flows where API interaction is required (e.g. mobile app, Smart TV, ...)

The login and registration flows documented here are the foundation for the
[password](user-login-user-registration/username-email-password.mdx) and
[social](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx)
sign in and sign up methods.

## Self-Service User Login and User Registration for Browser Applications

ORY Kratos supports browser applications that run on server-side (e.g. Java,
NodeJS, PHP) as well as client-side (e.g. JQuery, ReactJS, AngularJS, ...).

Browser-based login and registration makes use of three core HTTP technologies:

- HTTP Redirects
- HTTP POST (`application/json`, `application/x-www-urlencoded`) and RESTful GET
  requests.
- HTTP Cookies to prevent CSRF and Session Hijaking attack vectors.

The browser flow is the easiest and most secure to set up and integrated with.
ORY Kratos takes care of all required session and CSRF cookies and ensures that
all security requirements are fulfilled.

Future versions of ORY Kratos will be able to deal with multi-domain
environments that require SSO. For example, one account would be used to sign
into both `mydomain.com` and `anotherdomain.org`. A common real-world example is
using your Google account to seamlessly be signed into YouTube and Google at the
same time.

This flow is not suitable for scenarios where you use purely programmatic
clients that do not work well with HTTP Cookies and HTTP Redirects.

### The Login and Registration User Interface

The Login and Registration User Interface is a route (page / site) in your
application that should render a sign in and registration form:

```html
<!-- Login -->
<form action="..." method="POST">
  <input type="text" name="identifier" placeholder="Enter your username" />
  <input type="password" name="password" placeholder="Enter your password" />
  <input type="hidden" name="csrf_token" value="cdef..." />
  <input type="submit" />
</form>

<!-- Registration -->
<form action="..." method="POST">
  <input type="email" name="email" placeholder="Enter your E-Mail Address" />
  <input type="password" name="password" placeholder="Enter your password" />
  <input
    type="first_name"
    name="password"
    placeholder="Enter your First Name"
  />
  <input type="last_name" name="password" placeholder="Enter your Last Name" />
  <input type="hidden" name="csrf_token" value="cdef..." />
  <input type="submit" />
</form>
```

Once implemented (using e.g. our
[reference implementation](https://github.com/ory/kratos-selfservice-ui-node))
you reference these routes in your ORY Kratos config file:

```yaml title="path/to/config/kratos.yml"
# ...

urls:
  login_ui: https://.../login
  registration_ui: https://.../registration
# ...
```

Depending on the type of login flows you want to support, you may a also add a
"Sign up/in with GitHub" flow:

```html
<!-- Login and Registration -->
<form action="..." method="POST">
  <input type="hidden" name="csrf_token" value="cdef..." />

  <!-- Basically <a href="https://github.com/login/oauth/authorize?...">Sign up/in with GitHub</a> -->
  <input type="submit" name="provider" value="GitHub" />
</form>
```

In stark contrast to other Identity Systems, ORY Kratos does not render this
HTML. Instead, you need to implement the HTML code in your application (e.g.
NodeJS + ExpressJS, Java, PHP, ReactJS, ...), which gives you extreme
flexibility and customizability in your user interface flows and designs.

Each Login and Registration Strategy (e.g.
[Username and Password](user-login-user-registration/username-email-password.mdx),
[Social Sign In](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx),
Passwordless, ...) works a bit different but they all boil down to the same
abstract sequence:

<Mermaid
  chart={`
sequenceDiagram
  participant B as Browser
  participant K as ORY Kratos
  participant A as Your Application
  B->>K: Initiate Login
  K->>B: Redirects to your Application's /login endpoint
  B->>A: Calls /login
  A-->>K: Fetches data to render forms etc
  B-->>A: Fills out forms, clicks e.g. "Submit Login"
  B->>K: POSTs data to
  K-->>K: Processes Login Info
  alt Login data valid
    K-->>B: Sets session cookie
    K->>B: Redirects to e.g. Dashboard
  else Login data invalid
    K-->>B: Redirects to your Applicaiton's /login endpoint
    B->>A: Calls /login
    A-->>K: Fetches data to render form fields and errors
    B-->>A: Fills out forms again, corrects errors
    B->>K: POSTs data again - and so on...
  end
`}
/>

The exact data being fetched and the step _"Processes Login / Registration
Info"_ depend, of course, on the actual Strategy being used. But it is important
to understand that **"Your Application"** is responsible for rendering the
actual Login and Registration HTML Forms. You can of course implement one app
for rendering all the Login, Registration, ... screens, and another app (think
"Service Oriented Architecture", "Micro-Services" or "Service Mesh") is
responsible for rendering your Dashboards, Management Screens, and so on.

:::note

Please read the [Self-Service Flows](../../self-service) overview before
continuing with this document.

:::

<Mermaid
  chart={`
stateDiagram
  s1: Flow is initialized
  s2: Execute Before Login/Registration Hook(s)
  s3: User Interface renders Login/Registration Flow Forms
  s4: Execute After Login/Registration Hook(s)
  s5: Update Login/Registration Flow with Error Context(s)
  s6: Login/Registration successful
	[*] --> s1 : User clicks "Log in / Sign up"
  s1 --> s2
  s2 --> Error : A hook fails
  s2 --> s3
  s3 --> s4 : User provides valid credentials/registration data
  s3 --> s5 : User provides invalid credentials/registration data
  s5 --> s3
  s4 --> Error : A hook fails
  s4 --> s6
  s6 --> [*]
  Error --> [*]
`}
/>

## Self-Service User Login and User Registration for Browser Applications

Each Login and Registration Method (e.g.
[Username and Password](user-login-user-registration/username-email-password.mdx),
[Social Sign In](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx),
Passwordless, ...) works a bit different but they all boil down to the same
abstract sequence. This sequence was already established in the
[Self-Service Browser Flow Documentation](../../self-service#browser-flows).

<SelfServiceBrowserFlow
  flows={['login', 'registration']}
  success="Set session cookie or create user"
  interactions={['"Sign up"', '"Sign in"']}
/>

The flow payload and the form data the browser sends depend on the concrete flow
(registration, login) and method
([Username and Password](user-login-user-registration/username-email-password.mdx),
[Social Sign In](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx)).

The _Flow UI_ (**your application!**) is responsible for rendering the actual
Login and Registration HTML Forms. You can of course implement one app for
rendering all the Login, Registration, ... screens, and another app (think
"Service Oriented Architecture", "Micro-Services" or "Service Mesh") is
responsible for rendering your Dashboards, Management Screens, and so on.

### Initialization and Redirect to UI

To initialize the Login or Registration flow, point the Browser to
[the initialization endpoint](../../self-service#initialization-and-redirect-to-ui):

<Tabs
  defaultValue="curl"
  values={[
    {label: 'curl', value: 'curl'},
    {label: 'NodeJS', value: 'nodejs'},
  ]}>
  <TabItem value="curl">
  <InitBrowserFlow />
</TabItem>
</Tabs>

for login (`/self-service/login/browser`) or registration
(`/self-service/registration/browser`) and is redirected to the UI configured at

```yaml title="path/to/config/kratos.yml"
selfservice:
  flows:
    login:
      ui_url: http://...
    registration:
      ui_url: http://...
```

### Login and Registration Form Rendering

The Login and Registration User Interface is a route (page / site) in your
application (both server side application or single page app) that should render
a sign in and registration form:

<Tabs
  defaultValue="login"
  values={[
    {label: 'Login HTML', value: 'login'},
    {label: 'Registration HTML', value: 'registration'},
  ]}>
<TabItem value="login">

```html
<form action="..." method="POST">
  <input type="text" name="identifier" placeholder="Enter your username" />
  <input type="password" name="password" placeholder="Enter your password" />
  <input type="hidden" name="csrf_token" value="cdef..." />
  <input type="submit" />
</form>
```

</TabItem>
<TabItem value="registration">

```html
<form action="..." method="POST">
  <input type="email" name="email" placeholder="Enter your E-Mail Address" />
  <input type="password" name="password" placeholder="Enter your password" />
  <input
    type="first_name"
    name="password"
    placeholder="Enter your First Name"
  />
  <input type="last_name" name="password" placeholder="Enter your Last Name" />
  <input type="hidden" name="csrf_token" value="cdef..." />
  <input type="submit" />
</form>
```

</TabItem>
</Tabs>

Depending on the type of login flows you want to support, you may also add a
"Sign up/in with GitHub" flow:

<Tabs
  defaultValue="login"
  values={[
    {label: 'Login HTML', value: 'login'},
    {label: 'Registration HTML', value: 'registration'},
  ]}>
<TabItem value="login">

```html
<form action="..." method="POST">
  <input type="hidden" name="csrf_token" value="cdef..." />

  <strong>Sign in with:</strong>
  <input type="submit" name="provider" value="GitHub" />
  <input type="submit" name="provider" value="Google" />
  <input type="submit" name="provider" value="..." />
</form>
```

</TabItem>
<TabItem value="registration">

```html
<form action="..." method="POST">
  <input type="hidden" name="csrf_token" value="cdef..." />

  <strong>Sign up with:</strong>
  <input type="submit" name="provider" value="GitHub" />
  <input type="submit" name="provider" value="Google" />
  <input type="submit" name="provider" value="..." />
</form>
```

</TabItem>
</Tabs>

In stark contrast to other Identity Systems, ORY Kratos does not render this
HTML. Instead, you need to implement the HTML code in your application (e.g.
NodeJS + ExpressJS, Java, PHP, ReactJS, ...), which gives you extreme
flexibility and customizability in your user interface flows and designs.

### Code Examples

Because Login and Registration are so similar, we can use one common piece of
code to cover both. A functioning example of the code and approach used here can
be found on
[github.com/ory/kratos-selfservice-ui-node](https://github.com/ory/kratos-selfservice-ui-node).

<Tabs
  defaultValue="express"
  values={[
    {label: 'ExpressJS & Handlebars', value: 'express'},
    {label: 'ReactJS', value: 'react'},
  ]}>
<TabItem value="express">

<CodeFromRemote
  link="https://github.com/ory/kratos-selfservice-ui-node/blob/master/src/routes/auth.ts"
  src="https://raw.githubusercontent.com/ory/kratos-selfservice-ui-node/master/src/routes/auth.ts"
/>

The views can be rather simple, as ORY Kratos provides you with all the
information you need for rendering the forms.

The following examples use Handlebars and a generic form generator to render the
Flow:

<Tabs
  defaultValue="login"
  values={[
    {label: 'Login View', value: 'login'},
    {label: 'Registration View', value: 'registration'},
    {label: 'Generic Form View', value: 'generic-form'},
  ]}>

<TabItem value="login">

<CodeFromRemote
  link="https://github.com/ory/kratos-selfservice-ui-node/blob/master/views/login.hbs"
  src="https://raw.githubusercontent.com/ory/kratos-selfservice-ui-node/master/views/login.hbs"
/>

</TabItem>
<TabItem value="registration">

<CodeFromRemote
  link="https://github.com/ory/kratos-selfservice-ui-node/blob/master/views/registration.hbs"
  src="https://raw.githubusercontent.com/ory/kratos-selfservice-ui-node/master/views/registration.hbs"
/>

</TabItem>

<TabItem value="generic-form">

<CodeFromRemote
  link="https://github.com/ory/kratos-selfservice-ui-node/blob/master/views/partials/form.hbs"
  src="https://raw.githubusercontent.com/ory/kratos-selfservice-ui-node/master/views/partials/form.hbs"
/>

</TabItem>
</Tabs>

The rest of the form partials can be found
[here](https://github.com/ory/kratos-selfservice-ui-node/tree/master/views/partials).

</TabItem>
<TabItem value="react">

A react example is currently in the making.

</TabItem>
</Tabs>

For details on payloads consult the individual Self-Service Methods for:

- [Username and Password Method](user-login-user-registration/username-email-password.mdx)
- [Social Sign In Method](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx)

## Self-Service User Login and User Registration for API Clients

Each Login and Registration Method (e.g.
[Username and Password](user-login-user-registration/username-email-password.mdx),
[Social Sign In](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx),
Passwordless, ...) works a bit different but they all boil down to the same
abstract sequence. This sequence was already established in the
[Self-Service API Flow Documentation](../../self-service#api-flows).

<SelfServiceAPIFlow
  flows={['login', 'registration']}
  success="Set session cookie or create user"
  interactions={['"Sign up"', '"Sign in"']}
/>

The flow payload and the form data the browser sends depend on the concrete flow
(registration, login) and method
([Username and Password](user-login-user-registration/username-email-password.mdx),
[Social Sign In](user-login-user-registration/openid-connect-social-sign-in-oauth2.mdx)).

### Initialization

The client
[calls the API-flow initialization endpoint](../../self-service#initialization)
for login (`/self-service/login/api`) or registration
(`/self-service/login/api`). The response is a JSON payload containing
information about the flow.

### Login and Registration Form Rendering

The form is rendered as established in the
[API flow form rendering documentation](../../self-service#form-rendering-1).

### Form Submission

To submit the form, follow
[API flow form submission and payload validation](../../self-service#form-submission-and-payload-validation-1).

### Code Examples

<Tabs
  defaultValue="login-rn"
  values={[
    {label: 'Login React Native', value: 'login-rn'},
    {label: 'Registration React Native', value: 'registration-rn'},
  ]}>
<TabItem value="login-rn">

Code samples will follow soon

</TabItem>
<TabItem value="registration-rn">

Code samples will follow soon

</TabItem>
</Tabs>

## Hooks

ORY Kratos allows you to configure hooks that run before and after a Login or
Registration Request is generated. This may be helpful if you'd like to restrict
logins to IPs coming from your internal network or other logic.

For more information about hooks please read the [Hook Documentation](../hooks).

## Refreshing a Session

In some cases it is required to refresh a login session. This is the case when
updating one's password. Refreshing a session updates the `authenticated_at`
time.

:::info

Refreshing a session will not log the user out, unless another user signs in.

:::

To refresh a session, append `?refresh=true` to `/self-service/login/browser`,
for example
`http://127.0.0.1:4455/.ory/kratos/public/self-service/login/browser?refresh=true`.
